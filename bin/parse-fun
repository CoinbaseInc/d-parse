#!/usr/bin/env ruby

require 'd-parse'

Position = DParse::Position
Nothing  = DParse::Nothing
NOTHING  = DParse::NOTHING
Success  = DParse::Success
Failure  = DParse::Failure
Parser   = DParse::Parser

AnyParser         = DParse::Parsers::Any
CapturingParser   = DParse::Parsers::Capturing
CharParser        = DParse::Parsers::Char
EndOfInputParser  = DParse::Parsers::EndOfInput
IntersperseParser = DParse::Parsers::Intersperse
LazyParser        = DParse::Parsers::Lazy
NotCharParser     = DParse::Parsers::NotChar
NotCharsParser    = DParse::Parsers::NotChars
OrParser          = DParse::Parsers::Or
RepeatParser      = DParse::Parsers::Repeat
SequenceParser    = DParse::Parsers::Sequence
StringParser      = DParse::Parsers::String
WhitespaceParser  = DParse::Parsers::Whitespace

#############################################################################

digit_parser =
  OrParser.new(
    *(('0'..'9').map { |c| CharParser.new(c) }),
  )

identifier_char_parser =
  OrParser.new(
    *(('a'..'z').map { |c| CharParser.new(c) }),
  )

identifier_parser =
  (identifier_char_parser >> identifier_char_parser.repeat).capture

lit_parser =
  (digit_parser >> digit_parser.repeat).capture.map { |d| d.to_i(10) }

funcall_parser = nil

expression_parser =
  LazyParser.new { funcall_parser } | lit_parser

funcall_parser =
  (
    identifier_parser >>
    CharParser.new('(') >>
    expression_parser >>
    RepeatParser.new(
      SequenceParser.new(
        CharParser.new(','),
        WhitespaceParser.new,
        expression_parser,
      ).map { |d| d[2] },
    ) >>
    CharParser.new(')')
  ).map { |d| [d[0], d[2]] + d[3] }

##############################

def eval_expr(expr)
  case expr
  when Array
    case expr[0]
    when 'add'
      eval_expr(expr[1]) + eval_expr(expr[2])
    when 'mul'
      eval_expr(expr[1]) * eval_expr(expr[2])
    else
      raise '???'
    end
  when Integer
    expr
  else
    raise '???'
  end
end

expr = parse_from_argv(expression_parser)

require 'pp'
pp expr

p eval_expr(expr)
