#!/usr/bin/env ruby

require 'd-parse'
require 'pp'

CharParser        = DParse::Parsers::Char
CharsParser       = DParse::Parsers::Chars
EndOfInputParser  = DParse::Parsers::EndOfInput
LazyParser        = DParse::Parsers::Lazy
WhitespaceParser  = DParse::Parsers::Whitespace

digit =
  CharsParser.new(*('0'..'9'))

identifier_char =
  CharsParser.new(*('a'..'z'))

identifier =
  (identifier_char >> identifier_char.repeat).capture

lit =
  (digit >> digit.repeat).capture.map { |d| d.to_i(10) }

funcall = nil

expression =
  LazyParser.new { funcall } | lit

lparen = CharParser.new('(')
rparen = CharParser.new(')')
comma = CharParser.new(',')

arglist_tail =
  (comma >> WhitespaceParser.new >> expression).map { |d| d[2] }.repeat

arglist =
  (expression >> arglist_tail).map { |d| [d[0]] + d[1] }

funcall =
  (identifier >> lparen >> arglist >> rparen).map { |d| [d[0]] + d[2] }

eof =
  (CharParser.new("\n") >> EndOfInputParser.new) | EndOfInputParser.new

program = (expression >> eof).map { |d| d[0] }

##############################

def eval_expr(expr)
  case expr
  when Array
    case expr[0]
    when 'add'
      eval_expr(expr[1]) + eval_expr(expr[2])
    when 'mul'
      eval_expr(expr[1]) * eval_expr(expr[2])
    else
      raise '???'
    end
  when Integer
    expr
  else
    raise '???'
  end
end

expr = parse_from_argv(program)
pp expr
p eval_expr(expr)
